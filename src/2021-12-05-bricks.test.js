/*
문제 설명
주어진 벽돌을 이용해 벽을 쌓았을 때, 벽의 높이를 얼마나 다양하게 만들 수 있는지 알아보려 합니다.

주어진 벽돌의 높이는 1로 모두 같지만, 너비는 제각기 다를 수 있습니다. 벽을 쌓을 때 지켜야 하는 규칙은 다음과 같습니다.

주어진 벽돌을 순서대로 이용하되, 모든 벽돌을 이용하여 벽을 쌓아야 합니다.
벽돌은 왼쪽에서 오른쪽으로 빈틈없이 이어 붙여 쌓아야 합니다. 단, 아래층을 모두 쌓은 다음에 위층을 쌓을 수 있습니다.
모든 층의 너비는 같아야 합니다. 즉, 완성된 벽의 형태는 하나의 직사각형이어야 합니다.
벽돌을 회전하거나 세워서 쌓을 수 없습니다.
예를 들어, 주어진 벽돌의 너비가 순서대로 [2, 1, 1, 2]인 경우, 벽을 쌓는 방법은 다음과 같이 3가지가 있습니다.

1층에 모든 벽돌을 사용하여, 너비가 6, 높이가 1인 벽을 쌓습니다.
1층에 첫 번째와 두 번째 벽돌을 사용하고, 2층에 세 번째와 네 번째 벽돌을 사용하여, 너비가 3, 높이가 2인 벽을 쌓습니다.
1층에 첫 번째 벽돌, 2층에 두 번째와 세 번째 벽돌, 3층에 네 번째 벽돌을 사용하여, 너비가 2, 높이가 3인 벽을 쌓습니다.
즉, 만들 수 있는 벽의 높이는 [1, 2, 3] 입니다.

사용해야 하는 벽돌의 너비를 순서대로 담은 정수 배열 bricks가 매개변수로 주어집니다. 규칙에 따라 만들 수 있는 벽의 높이를 배열에 담아 오름차순 정렬하여 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ bricks의 길이 ≤ 1,000
1 ≤ bricks의 원소 ≤ 100
입출력 예
bricks	result
[2, 1, 1, 2]	[1, 2, 3]
[1, 2, 3, 2, 1]	[1, 3]
[1, 1, 1, 1, 1, 1]	[1, 2, 3, 6]
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

벽을 쌓는 방법은 다음과 같이 2가지가 있습니다.

1층에 모든 벽돌을 사용하여 높이가 1인 벽을 쌓습니다.
1층에 첫 번째와 두 번째 벽돌을 사용, 2층에 세 번째 벽돌을 사용, 3층에 나머지 벽돌을 모두 사용하여, 너비가 3, 높이가 3인 벽을 쌓습니다.
가능한 벽의 높이는 1, 3입니다. 따라서 [1, 3]을 return 합니다.

입출력 예 #3

모든 벽돌의 너비가 1로 같기 때문에, 너비와 높이가 (1, 6), (2, 3), (3, 2), (6, 1)인 벽을 쌓을 수 있습니다.
따라서 [1, 2, 3, 6]을 return 합니다.
*/


function solution(bricks){
  const map = new Map()
  let sum = 0
  for(const width of bricks){
    sum += width
    map.set(sum, true)
  }
  for(const [key, value] of map){
    if(sum % key === 0){
      for(let i=key+key; i<sum; i+=key){
        if(!map.has(i)){
          map.set(key, false)
          break
        }
      }
    }else{
      map.set(key, false)
    }
  }
  return Array.from(map).flatMap(item => item[1] ? sum / item[0] : []).reverse()
}

test('bricks', () => {
  expect(solution([2, 1, 1, 2])).toEqual([1, 2, 3])
  expect(solution([1, 2, 3, 2, 1])).toEqual([1, 3])
  expect(solution([1, 1, 1, 1, 1, 1])).toEqual([1, 2, 3, 6])
})
